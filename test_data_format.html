<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>数据格式测试</title>
</head>
<body>
    <h1>7.5"V2 数据格式测试</h1>
    <button onclick="testDataFormat()">测试数据格式</button>
    <pre id="output"></pre>
    
    <script>
    function byteToStr(byte) {
        const low = byte & 0x0F;
        const high = (byte >> 4) & 0x0F;
        return String.fromCharCode(97 + low) + String.fromCharCode(97 + high);
    }
    
    function wordToStr(value) {
        const lowByte = value & 0xFF;
        const highByte = (value >> 8) & 0xFF;
        return byteToStr(lowByte) + byteToStr(highByte);
    }
    
    function testDataFormat() {
        const output = document.getElementById('output');
        let log = '';
        
        // 创建简单测试数据：4x4像素（16像素 = 2字节）
        const pixelArray = [
            0, 1, 0, 1,  // 第1行：黑白黑白
            1, 0, 1, 0,  // 第2行：白黑白黑
            0, 1, 0, 1,  // 第3行：黑白黑白
            1, 0, 1, 0   // 第4行：白黑白黑
        ];
        
        log += '=== 测试数据 ===\n';
        log += `像素数组(4x4=16像素): ${pixelArray.join(',')}\n\n`;
        
        // 转换为字节（使用原版u_data c=0逻辑）
        const byteArray = [];
        for (let i = 0; i < pixelArray.length; i += 8) {
            let byte = 0;
            for (let bit = 0; bit < 8 && (i + bit) < pixelArray.length; bit++) {
                // if (a[pxInd++]!=c) v|=(128>>i);
                // 当c=0时，如果像素!=0，设置该位
                if (pixelArray[i + bit] != 0) {
                    byte |= (128 >> bit);
                }
            }
            byteArray.push(byte);
            log += `字节${Math.floor(i/8)}: 像素[${pixelArray.slice(i, i+8).join(',')}] → 0x${byte.toString(16).padStart(2,'0').toUpperCase()} (二进制:${byte.toString(2).padStart(8,'0')})\n`;
        }
        
        log += `\n字节数组: [${byteArray.map(b => '0x'+b.toString(16).toUpperCase()).join(', ')}]\n\n`;
        
        // 编码为字符串
        let dataString = '';
        for (let i = 0; i < byteArray.length; i++) {
            const encoded = byteToStr(byteArray[i]);
            dataString += encoded;
            log += `编码字节${i}(0x${byteArray[i].toString(16).padStart(2,'0').toUpperCase()}): "${encoded}"\n`;
        }
        
        log += `\n编码后字符串: "${dataString}"\n`;
        log += `字符串长度: ${dataString.length}\n\n`;
        
        // 添加长度后缀
        const lengthWord = wordToStr(dataString.length);
        log += `=== 长度后缀 ===\n`;
        log += `数据长度: ${dataString.length}\n`;
        log += `长度编码(word): "${lengthWord}"\n\n`;
        
        // 完整数据块
        const fullData = dataString + lengthWord + 'LOAD';
        log += `=== 完整数据块 ===\n`;
        log += `"${fullData}"\n`;
        log += `总长度: ${fullData.length} (数据${dataString.length} + 长度4 + LOAD4)\n\n`;
        
        log += `=== 缓冲区末尾8字符 ===\n`;
        log += `应该是: [长度word(4字符)][LOAD(4字符)]\n`;
        log += `实际是: "${fullData.substring(fullData.length - 8)}"\n`;
        
        output.textContent = log;
    }
    </script>
</body>
</html>
